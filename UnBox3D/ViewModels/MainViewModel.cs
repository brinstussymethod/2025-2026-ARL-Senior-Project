using CommunityToolkit.Mvvm.ComponentModel;
using CommunityToolkit.Mvvm.Input;
using System.Collections.ObjectModel;
using UnBox3D.Models;
using UnBox3D.Utils;
using UnBox3D.Rendering;
using System.Diagnostics;
using System.IO;
using System.Windows;
using UnBox3D.Views;
using UnBox3D.Controls;
using UnBox3D.Rendering.OpenGL;
using UnBox3D.Commands;
using OpenTK.Mathematics;
using PdfSharpCore.Pdf;

namespace UnBox3D.ViewModels
{
    public partial class MainViewModel : ObservableObject
    {
        #region Fields & Properties

        private readonly ILogger _logger;
        private readonly ISettingsManager _settingsManager;
        private readonly ISceneManager _sceneManager;
        private readonly IGLControlHost _glControlHost;
        private readonly ModelImporter _modelImporter;
        private readonly MouseController _mouseController;
        private readonly ICamera _camera;
        private readonly IFileSystem _fileSystem;
        private readonly BlenderIntegration _blenderIntegration;
        private readonly IBlenderInstaller _blenderInstaller;
        private readonly ModelExporter _modelExporter;
        private readonly ICommandHistory _commandHistory;
        private string _importedFilePath; // Global filepath that should be referenced when simplifying
        private double _importScaleFactor = 1.0; // Scale factor applied during import (to reverse for real-world unfolding)
        private List<IAppMesh> _latestImportedModel; // This is so we can keep track of the original model when playing around with small mesh thresholds.
        private IAppMesh _lastSelectedMesh; // Keep track of the previously selected mesh so we can remove its highlight
        private Vector3 _normalColor;    // Color used for unselected meshes
        private Vector3 _highlightColor; // Color used for currently selected mesh

        // This property is generated by CommunityToolkit.MVVM and raises change notifications.
        // We react to it in OnSelectedMeshChanged below.
        [ObservableProperty]
        private IAppMesh selectedMesh;

        [ObservableProperty]
        private bool hierarchyVisible = true;

        [ObservableProperty]
        private float pageWidth = 25.0f;

        [ObservableProperty]
        private float pageHeight = 25.0f;

        [ObservableProperty]
        private float cardboardSheetWidth = 1828.8f; // mm (default 6ft)

        [ObservableProperty]
        private float cardboardSheetHeight = 1524.0f; // mm (default 5ft)

        [ObservableProperty]
        private float simplificationRatio = 50f; // represents percentage (10–100)

        [ObservableProperty]
        private float smallMeshThreshold = 0f;

        public ObservableCollection<MeshSummary> Meshes { get; } = new();

        #endregion

        #region Constructor

        public MainViewModel(ILogger logger, ISettingsManager settingsManager, ISceneManager sceneManager,
            IFileSystem fileSystem, BlenderIntegration blenderIntegration,
            IBlenderInstaller blenderInstaller, ModelExporter modelExporter,
            MouseController mouseController, IGLControlHost glControlHost, ICamera camera, ICommandHistory commandHistory)
        {
            _logger = logger;
            _settingsManager = settingsManager;
            _sceneManager = sceneManager;
            _fileSystem = fileSystem;
            _blenderIntegration = blenderIntegration;
            _blenderInstaller = blenderInstaller;
            _modelImporter = new ModelImporter(_settingsManager);
            _modelExporter = modelExporter;
            _mouseController = mouseController;
            _glControlHost = glControlHost;
            _camera = camera;
            _commandHistory = commandHistory;

            LoadColors();
        }

        #endregion

        #region Model Import Methods

        [RelayCommand]
        private void ImportObjModel()
        {
            var openFileDialog = new Microsoft.Win32.OpenFileDialog
            {
                Filter = "3D Models (*.obj;)|*.obj;"
            };

            // Show the dialog and check if the result is true
            bool? result = openFileDialog.ShowDialog();
            if (result == true)
            {
                string filePath = openFileDialog.FileName;
                _importedFilePath = EnsureImportDirectory(filePath);
                List<IAppMesh> importedMeshes = _modelImporter.ImportModel(_importedFilePath);
                _importScaleFactor = _modelImporter.ScaleFactor;

                _latestImportedModel = importedMeshes; // Purpose: Remember the model that was imported so that the user can freely mess with something like size thresholds and go back.

                foreach (var mesh in importedMeshes)
                {
                    _sceneManager.AddMesh(mesh);
                    Meshes.Add(new MeshSummary(mesh));
                }

                if (_modelImporter.WasScaled)
                {
                    var exportPath = _modelExporter.ExportToObj(_sceneManager.GetMeshes().ToList());
                    if (exportPath != null)
                    {
                        _importedFilePath = exportPath;
                    }

                }
            }
        }

        // Don't call this function directly.
        // Reference _importedFilePath if you want access to the ImportedModels directory.
        private string EnsureImportDirectory(string filePath)
        {
            string importDirectory = _fileSystem.CombinePaths(AppDomain.CurrentDomain.BaseDirectory, "ImportedModels");

            if (!_fileSystem.DoesDirectoryExists(importDirectory))
            {
                _fileSystem.CreateDirectory(importDirectory);
            }

            string destinationPath = _fileSystem.CombinePaths(importDirectory, Path.GetFileName(filePath));
            try
            {
                File.Copy(filePath, destinationPath, overwrite: true);
            }
            catch (IOException ex)
            {
                throw new InvalidOperationException("Failed to copy file to ImportedModels directory.", ex);
            }


            return destinationPath;
        }

        #endregion

        #region Unfolding Process Methods

        private async Task ProcessUnfolding(string inputModelPath)
        {
            Debug.WriteLine("Input model is coming from: " + inputModelPath);

            if (string.IsNullOrWhiteSpace(inputModelPath) || !File.Exists(inputModelPath))
            {
                Debug.WriteLine($"ProcessUnfolding: inputModelPath missing or not found: '{inputModelPath}'");
                await ShowWpfMessageBoxAsync("The input model file was not found. Ensure the file exists before unfolding.", "Input Error", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            var installWindow = new LoadingWindow
            {
                StatusHint = "Installing Blender...",
                Owner = System.Windows.Application.Current.MainWindow,
                IsProgressIndeterminate = false
            };
            installWindow.Show();

            var installProgress = new Progress<double>(value =>
            {
                installWindow.UpdateProgress(value * 100);
                installWindow.UpdateStatus($"Installing Blender... {Math.Round(value * 100)}%");
            });

            await _blenderInstaller.CheckAndInstallBlender(installProgress);
            installWindow.Close();

            if (!_blenderInstaller.IsBlenderInstalled())
            {
                await ShowWpfMessageBoxAsync(
                    "Blender is required to unfold models but was not found. Please install Blender before proceeding.",
                    "Missing Dependency", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            try
            {
                var loadingWindow = new LoadingWindow
                {
                    StatusHint = "This may take several minutes depending on model complexity",
                    Owner = System.Windows.Application.Current.MainWindow,
                    IsProgressIndeterminate = false
                };
                loadingWindow.Show();

                if (_fileSystem == null || _blenderIntegration == null)
                {
                    loadingWindow.Close();
                    await ShowWpfMessageBoxAsync("Internal error: dependencies not initialized.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                if (PageWidth == 0 || PageHeight == 0)
                {
                    loadingWindow.Close();
                    await ShowWpfMessageBoxAsync("Page Dimensions cannot be 0.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                var saveFileDialog = new Microsoft.Win32.SaveFileDialog
                {
                    Title = "Save your unfolded file",
                    Filter = "SVG Files|*.svg|PDF Files|*.pdf",
                    FileName = "MyUnfoldedFile"
                };

                bool? dialogResult = saveFileDialog.ShowDialog();
                if (dialogResult != true)
                {
                    loadingWindow.Close();
                    return;
                }

                string filePath = saveFileDialog.FileName;
                string ext = Path.GetExtension(filePath).ToLowerInvariant();
                string? userSelectedPath = Path.GetDirectoryName(filePath);

                if (string.IsNullOrEmpty(userSelectedPath))
                {
                    loadingWindow.Close();
                    await ShowWpfMessageBoxAsync("Unable to determine the selected directory.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                string newFileName = Path.GetFileNameWithoutExtension(filePath);
                string format = ext == ".pdf" ? "PDF" : "SVG";

                string baseDir = AppDomain.CurrentDomain.BaseDirectory;
                string outputDirectory = _fileSystem.CombinePaths(baseDir, "UnfoldedOutputs");
                string scriptPath = _fileSystem.CombinePaths(baseDir, "Scripts", "unfolding_script.py");

                // immediate checks to help diagnose "no output" issues
                Debug.WriteLine($"ProcessUnfolding: baseDirectory: {baseDir}");
                Debug.WriteLine($"ProcessUnfolding: outputDirectory: {outputDirectory}");
                Debug.WriteLine($"ProcessUnfolding: scriptPath: {scriptPath}");
                Debug.WriteLine($"ProcessUnfolding: inputModelPath full: {Path.GetFullPath(inputModelPath)}");

                if (!File.Exists(scriptPath))
                {
                    loadingWindow.Close();
                    Debug.WriteLine("ProcessUnfolding: unfolding_script.py not found.");
                    await ShowWpfMessageBoxAsync($"Unfolding script missing: {scriptPath}", "Script Missing", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                if (!_fileSystem.DoesDirectoryExists(outputDirectory))
                    _fileSystem.CreateDirectory(outputDirectory);

                // clear previous outputs
                CleanupUnfoldedFolder(outputDirectory);

                double incrementWidth = PageWidth;
                double incrementHeight = PageHeight;
                bool success = false;
                string errorMessage = "";
                int iteration = 0;

                loadingWindow.UpdateStatus("Preparing Blender environment...");
                await DispatcherHelper.DoEvents();

                while (!success)
                {
                    iteration++;

                    const int maxRetries = 20;
                    if (iteration > maxRetries)
                    {
                        loadingWindow.Close();
                        await ShowWpfMessageBoxAsync(
                            $"Failed after {maxRetries} attempts. The model could not be unfolded.",
                            "Unfolding Failed", MessageBoxButton.OK, MessageBoxImage.Error);
                        return;
                    }

                    loadingWindow.UpdateStatus($"Processing with Blender (Attempt {iteration})...");
                    loadingWindow.UpdateProgress((double)iteration / maxRetries * 50);
                    await DispatcherHelper.DoEvents();

                    // Calculate inverse scale to restore real-world dimensions
                    double inverseScale = (_importScaleFactor != 0 && _importScaleFactor != 1.0) 
                        ? 1.0 / _importScaleFactor 
                        : 1.0;

                    // run the script and capture returned errorMessage
                    success = await Task.Run(() =>
                        _blenderIntegration.RunBlenderScript(
                            inputModelPath, outputDirectory, scriptPath,
                            newFileName, incrementWidth, incrementHeight, "SVG", out errorMessage,
                            inverseScale));

                    Debug.WriteLine($"RunBlenderScript returned success={success}; errorMessage='{errorMessage}'");
                    // list output directory immediately after call to see what was produced
                    try
                    {
                        var produced = Directory.Exists(outputDirectory)
                            ? Directory.GetFiles(outputDirectory).Select(Path.GetFileName).ToArray()
                            : Array.Empty<string>();
                        Debug.WriteLine("Files in outputDirectory after RunBlenderScript:");
                        foreach (var f in produced) Debug.WriteLine(f);
                    }
                    catch (Exception ex)
                    {
                        Debug.WriteLine($"Failed listing outputDirectory: {ex}");
                    }

                    if (!success)
                    {
                        if (!string.IsNullOrEmpty(errorMessage) && errorMessage.Contains("continue"))
                        {
                            incrementWidth++;
                            incrementHeight++;
                            loadingWindow.UpdateStatus($"Retrying with new dimensions: {incrementWidth} x {incrementHeight}");
                            await DispatcherHelper.DoEvents();
                        }
                        else
                        {
                            loadingWindow.Close();
                            await loadingWindow.Dispatcher.InvokeAsync(() =>
                            {
                                System.Windows.Application.Current.MainWindow?.Activate();
                                System.Windows.MessageBox.Show(
                                    errorMessage ?? "Unknown error running Blender/unfolding script.",
                                    "Error Processing File",
                                    MessageBoxButton.OK,
                                    MessageBoxImage.Error,
                                    MessageBoxResult.OK,
                                    System.Windows.MessageBoxOptions.DefaultDesktopOnly);
                            });
                            return;
                        }
                    }
                }

                loadingWindow.UpdateStatus("Processing unfolded panels...");
                await DispatcherHelper.DoEvents();

                // capture files produced by blender
                string[] svgPanelFiles = Array.Empty<string>();
                try
                {
                    svgPanelFiles = Directory.GetFiles(outputDirectory, "*.svg");
                    Debug.WriteLine($"Found {svgPanelFiles.Length} svg files in '{outputDirectory}'");
                    foreach (var f in svgPanelFiles) Debug.WriteLine($"  -> {f}");
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"Error getting svg files: {ex}");
                }

                if (svgPanelFiles.Length == 0)
                {
                    loadingWindow.Close();
                    Debug.WriteLine($"No SVG files found in output directory '{outputDirectory}'. errorMessage: {errorMessage}");
                    await ShowWpfMessageBoxAsync(
                        $"Blender completed but did not produce SVG output in:\n{outputDirectory}\n\nBlender message: {errorMessage}",
                        "Unfold Error",
                        MessageBoxButton.OK,
                        MessageBoxImage.Error);
                    return;
                }

                int totalPanels = svgPanelFiles.Length;
                for (int i = 0; i < totalPanels; i++)
                {
                    string svgFile = svgPanelFiles[i];
                    loadingWindow.UpdateStatus($"Processing panel {i + 1} of {totalPanels}");
                    loadingWindow.UpdateProgress(50 + ((double)i / totalPanels * 30));
                    await DispatcherHelper.DoEvents();

                    // Add cardboard sheet grid overlay showing where to cut
                    await Task.Run(() => SVGEditor.AddCardboardGrid(svgFile, CardboardSheetWidth, CardboardSheetHeight));

                    // Crop the SVG to just the content area (removes empty whitespace)
                    await Task.Run(() => SVGEditor.CropToContent(svgFile));

                    // Rename to final output name (skip panel splitting — one file with grid overlay)
                    string destName = totalPanels == 1
                        ? $"{newFileName}.svg"
                        : $"{newFileName}_page{i + 1}.svg";
                    string destPath = Path.Combine(outputDirectory, destName);
                    if (!string.Equals(Path.GetFullPath(svgFile), Path.GetFullPath(destPath), StringComparison.OrdinalIgnoreCase))
                    {
                        File.Move(svgFile, destPath, overwrite: true);
                    }
                }

                // ... rest of method follows unchanged (exporting files, cleanup, notifications) ...
                loadingWindow.UpdateStatus("Exporting final files...");
                loadingWindow.UpdateProgress(80);
                await DispatcherHelper.DoEvents();

                bool anyFilesMoved = false;

                if (format == "SVG")
                {
                    string[] svgFiles = Directory.GetFiles(outputDirectory, $"{newFileName}*.svg");
                    int fileCount = svgFiles.Length;

                    if (fileCount == 0)
                    {
                        loadingWindow.Close();
                        await ShowWpfMessageBoxAsync("No SVG files were produced to export.", "Export Error", MessageBoxButton.OK, MessageBoxImage.Error);
                        return;
                    }

                    for (int i = 0; i < fileCount; i++)
                    {
                        string source = svgFiles[i];
                        string suffix = source.Substring(source.IndexOf(newFileName) + newFileName.Length);
                        string destination = Path.Combine(userSelectedPath, newFileName + suffix);

                        loadingWindow.UpdateStatus($"Exporting file {i + 1} of {fileCount}");
                        loadingWindow.UpdateProgress(80 + ((double)i / fileCount * 20));
                        await DispatcherHelper.DoEvents();

                        try
                        {
                            // Skip if source and destination are the same file
                            if (string.Equals(Path.GetFullPath(source), Path.GetFullPath(destination), StringComparison.OrdinalIgnoreCase))
                            {
                                Debug.WriteLine($"Source and destination are the same file, skipping copy: {source}");
                                anyFilesMoved = true;
                                continue;
                            }

                            // Small delay to let SVG editor release the file handle
                            await Task.Delay(100);

                            File.Copy(source, destination, overwrite: true);
                            File.Delete(source);
                            anyFilesMoved = true;
                        }
                        catch (Exception ex)
                        {
                            Debug.WriteLine($"Failed moving SVG file '{source}' -> '{destination}': {ex}");
                        }
                    }

                    var exportedInDest = Directory.GetFiles(userSelectedPath, $"{newFileName}*.svg");
                    if (!exportedInDest.Any())
                    {
                        loadingWindow.Close();
                        await ShowWpfMessageBoxAsync("Export reported success but no SVG files were found in the destination folder.", "Export Error", MessageBoxButton.OK, MessageBoxImage.Error);
                        return;
                    }
                }
                else if (format == "PDF")
                {
                    string pdfFile = Path.Combine(outputDirectory, $"{newFileName}.pdf");

                    string[] svgFiles = Directory.GetFiles(outputDirectory, $"{newFileName}_panel_page*.svg");
                    int fileCount = svgFiles.Length;

                    var pdf = new PdfDocument();
                    bool allSuccessful = true;

                    for (int i = 0; i < fileCount; i++)
                    {
                        string svgFile = svgFiles[i];
                        loadingWindow.UpdateStatus($"Combining file {i + 1} of {fileCount} into PDF...");
                        loadingWindow.UpdateProgress(80 + ((double)i / fileCount * 20));
                        await DispatcherHelper.DoEvents();

                        bool successful = await Task.Run(() => SVGEditor.ExportToPdf(svgFile, pdf));
                        if (!successful)
                        {
                            allSuccessful = false;
                            break;
                        }
                    }

                    if (allSuccessful)
                    {
                        try
                        {
                            pdf.Save(pdfFile);
                            string destination = Path.Combine(userSelectedPath, $"{newFileName}.pdf");
                            File.Copy(pdfFile, destination, overwrite: true);
                            File.Delete(pdfFile);
                            anyFilesMoved = true;
                        }
                        catch (Exception ex)
                        {
                            Debug.WriteLine($"Failed to save/move PDF: {ex}");
                        }
                    }
                    else
                    {
                        await ShowWpfMessageBoxAsync($"The SVG files are too large to be combined into partitioned panels for PDF. Will instead use the fallback PDF which may result in loss of some panels. Exporting will continue.", "Unable to allocate the required memory", MessageBoxButton.OK, MessageBoxImage.Warning);

                        Debug.WriteLine($"incrW: {incrementWidth} incrH: {incrementHeight}");

                        await Task.Run(() => _blenderIntegration.RunBlenderScript(
                            inputModelPath, outputDirectory, scriptPath,
                            newFileName, incrementWidth, incrementHeight, "PDF", out errorMessage));

                        if (File.Exists(pdfFile))
                        {
                            string destination = Path.Combine(userSelectedPath, $"{newFileName}.pdf");
                            try
                            {
                                File.Copy(pdfFile, destination, overwrite: true);
                                File.Delete(pdfFile);
                                anyFilesMoved = true;
                            }
                            catch (Exception ex)
                            {
                                Debug.WriteLine($"Failed to move fallback PDF: {ex}");
                            }
                        }
                    }

                    if (!anyFilesMoved)
                    {
                        loadingWindow.Close();
                        await ShowWpfMessageBoxAsync("Export reported success but no PDF file could be saved to the destination folder.", "Export Error", MessageBoxButton.OK, MessageBoxImage.Error);
                        return;
                    }
                }

                loadingWindow.UpdateStatus("Cleaning up temporary files...");
                loadingWindow.UpdateProgress(100);
                await DispatcherHelper.DoEvents();

                // Only clean up if the user chose a different destination folder
                if (!string.Equals(Path.GetFullPath(outputDirectory), Path.GetFullPath(userSelectedPath), StringComparison.OrdinalIgnoreCase))
                {
                    CleanupUnfoldedFolder(outputDirectory);
                }

                loadingWindow.Close();

                await ShowWpfMessageBoxAsync($"{format} file has been exported successfully!",
                    "Export Complete", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"ProcessUnfolding exception: {ex}");
                await ShowWpfMessageBoxAsync($"Unexpected error: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }
        [RelayCommand]
        private async Task UnfoldMesh(IAppMesh mesh)
        {
            if (mesh == null)
                return;

            // 1. Export the single mesh to a temporary .obj file
            string fileName = $"unfold_temp_{Guid.NewGuid()}.obj";
            string? exportedPath = null;

            try
            {
                exportedPath = _modelExporter.ExportToObj(new List<IAppMesh> { mesh }, fileName);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"UnfoldMesh: ExportToObj threw: {ex}");
                await ShowWpfMessageBoxAsync($"Failed to export mesh for unfolding: {ex.Message}", "Export Error",
                                             MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            // Validate the returned path and attempt a few reasonable fallbacks if necessary.
            bool PathIsValid(string? p) => !string.IsNullOrWhiteSpace(p) && File.Exists(p) && Path.GetExtension(p).Equals(".obj", StringComparison.OrdinalIgnoreCase);

            if (!PathIsValid(exportedPath))
            {
                // try a few likely locations if the exporter returned a relative filename or null
                var candidates = new[]
                {
            exportedPath ?? string.Empty,
            Path.Combine(AppDomain.CurrentDomain.BaseDirectory, fileName),
            Path.Combine(Path.GetTempPath(), fileName)
        }.Where(p => !string.IsNullOrWhiteSpace(p)).ToArray();

                string? found = candidates.FirstOrDefault(PathIsValid);

                if (found != null)
                {
                    exportedPath = found;
                }
                else
                {
                    string tried = string.Join(Environment.NewLine, candidates);
                    Debug.WriteLine($"UnfoldMesh: ExportToObj returned invalid path. Tried:{Environment.NewLine}{tried}");
                    await ShowWpfMessageBoxAsync(
                        "Failed to export mesh for unfolding. The exporter did not produce a valid .obj file.\n" +
                        "If this persists, verify that ModelExporter.ExportToObj writes an absolute path and that the file exists.",
                        "Export Error",
                        MessageBoxButton.OK,
                        MessageBoxImage.Error);
                    return;
                }
            }

            // 2. Unfold just this mesh using the same logic you already have
            try
            {
                await ProcessUnfolding(exportedPath);
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"UnfoldMesh: ProcessUnfolding threw: {ex}");
                await ShowWpfMessageBoxAsync($"Unfolding failed: {ex.Message}", "Unfold Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }


        private void CleanupUnfoldedFolder(string folderPath)
        {
            try
            {
                string[] files = Directory.GetFiles(folderPath);
                foreach (string file in files)
                {
                    File.Delete(file);
                }
            }
            catch (Exception ex)
            {
                // Synchronously show an error if cleanup fails.
                System.Windows.Application.Current.Dispatcher.Invoke(() =>
                {
                    System.Windows.Application.Current.MainWindow.Activate();
                    System.Windows.MessageBox.Show(
                        $"An error occurred during cleanup: {ex.Message}",
                        "Cleanup Error",
                        MessageBoxButton.OK,
                        MessageBoxImage.Error,
                        MessageBoxResult.OK,
                        System.Windows.MessageBoxOptions.DefaultDesktopOnly);
                });
            }
        }

        #endregion

        #region Relay Commands

        [RelayCommand]
        private async Task ExportUnfoldModel()
        {
            if (string.IsNullOrEmpty(_importedFilePath))
            {
                await ShowWpfMessageBoxAsync("No model imported to unfold.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }
            await ProcessUnfolding(_importedFilePath);
        }

        [RelayCommand]
        private async void ResetView()
        {
            await ShowWpfMessageBoxAsync("Resetting the view!", "Information", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        [RelayCommand]
        private void ToggleHierarchy()
        {
            HierarchyVisible = !HierarchyVisible;
        }

        [RelayCommand]
        private async void About()
        {
            await ShowWpfMessageBoxAsync("UnBox3D - A 3D Model Viewer", "About", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        [RelayCommand]
        private async Task ExportMesh(IAppMesh mesh)
        {
            if (mesh == null)
                return;

            var path = PromptForSaveLocation();
            if (string.IsNullOrWhiteSpace(path))
                return;

            var exported = _modelExporter.ExportToObjAbsolutePath(new List<IAppMesh> { mesh }, path);
            if (exported != null)
            {
                await ShowWpfMessageBoxAsync($"Exported mesh to: {exported}",
                                             "Export Mesh",
                                             MessageBoxButton.OK,
                                             MessageBoxImage.Information);
            }
            else
            {
                await ShowWpfMessageBoxAsync("Failed to export mesh.",
                                             "Export Mesh",
                                             MessageBoxButton.OK,
                                             MessageBoxImage.Error);
            }
        }

        [RelayCommand]
        private async Task ClearScene()
        {
            var result = await ShowWpfMessageBoxAsync("Are you sure you want to clear the scene?",
                                                      "Clear Scene",
                                                      MessageBoxButton.YesNo,
                                                      MessageBoxImage.Warning);
            if (result == MessageBoxResult.Yes)
            {
                _sceneManager.ClearScene();
                Meshes.Clear();
            }
        }

        [RelayCommand]
        private void DeleteMesh(IAppMesh mesh)
        {
            if (mesh == null)
                return;

            _sceneManager.DeleteMesh(mesh);

            // Dispose of the mesh's unmanaged resources
            if (mesh is IDisposable disposableMesh)
            {
                disposableMesh.Dispose();
            }

            // Remove the corresponding MeshSummary from the UI-bound collection.
            // Assuming Meshes is an ObservableCollection<MeshSummary>
            var summaryToRemove = Meshes.FirstOrDefault(ms => ms.SourceMesh == mesh);
            if (summaryToRemove != null)
            {
                Meshes.Remove(summaryToRemove);
            }
        }

        [RelayCommand]
        private async Task ExportModel()
        {
            // 1. Prompt user for the export path
            string? path = PromptForSaveLocation();
            if (string.IsNullOrEmpty(path))
                return; // user cancelled

            // 2. Export all meshes
            var meshesToExport = _sceneManager.GetMeshes().ToList();
            var savedPath = _modelExporter.ExportToObjAbsolutePath(meshesToExport, path);

            // 3. Notify user of success/failure
            if (savedPath != null)
            {
                await ShowWpfMessageBoxAsync($"Exported all meshes to: {savedPath}",
                                             "Export Meshes",
                                             MessageBoxButton.OK,
                                             MessageBoxImage.Information);
            }
            else
            {
                await ShowWpfMessageBoxAsync("Failed to export meshes.",
                                             "Export Meshes",
                                             MessageBoxButton.OK,
                                             MessageBoxImage.Error);
            }
        }

        #endregion

        #region Mesh Simplification Commands

        [RelayCommand]
        private async void ReplaceSceneWithBoundingBoxes()
        {
            // Value set from UI slider
            float threshold = SmallMeshThreshold;

            // 1. Generate bounding boxes and load them
            List<AppMesh> boxMeshList = _sceneManager.LoadBoundingBoxes();

            // 2. Clear the scene and UI
            _sceneManager.ClearScene();
            Meshes.Clear();

            // 3. Export the generated bounding boxes to a temp .obj file
            string tempFileName = $"bounding_boxes_scene_{Guid.NewGuid()}.obj";
            string? exportedPath = _modelExporter.ExportToObj(boxMeshList.Cast<IAppMesh>().ToList(), tempFileName);

            if (string.IsNullOrWhiteSpace(exportedPath))
            {
                await ShowWpfMessageBoxAsync("Failed to export bounding boxes.", "Export Error",
                                             MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            // 4. Re-import the exported .obj file to fully reload it into the scene
            var importedMeshes = _modelImporter.ImportModel(exportedPath);
            _importedFilePath = exportedPath;
            foreach (var mesh in importedMeshes)
            {
                _sceneManager.AddMesh(mesh);
                Meshes.Add(new MeshSummary(mesh));
            }
        }

        [RelayCommand]
        private async void ReplaceWithCylinderOption(IAppMesh mesh)
        {
            Vector3 center = _sceneManager.GetMeshCenter(mesh.GetG4Mesh());
            Vector3 meshDimensions = _sceneManager.GetMeshDimensions(mesh.GetG4Mesh());

            bool isXAligned = (meshDimensions.X < meshDimensions.Z);

            float radius = Math.Max(Math.Min(meshDimensions.X, meshDimensions.Z), meshDimensions.Y) / 2;
            float height = isXAligned ? meshDimensions.X : meshDimensions.Z;

            AppMesh cylinder = GeometryGenerator.CreateRotatedCylinder(center, radius, height, 32, Vector3.UnitX);

            var summaryToRemove = Meshes.FirstOrDefault(ms => ms.SourceMesh == mesh);
            if (summaryToRemove != null)
            {
                Meshes.Remove(summaryToRemove);
            }

            _sceneManager.ReplaceMesh(mesh, cylinder);

            Meshes.Add(new MeshSummary(cylinder));

            //await ShowWpfMessageBoxAsync("Replaced Mesh!", "Replace", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        // If you want to implement replace with cylinder by clicking
        [RelayCommand]
        private async void ReplaceWithCylinderClick()
        {
            var command = new SetReplaceStateCommand(_glControlHost, _mouseController, _sceneManager, new RayCaster(_glControlHost, _camera), _camera, _commandHistory, "cylinder");
            command.Execute();
            await ShowWpfMessageBoxAsync("Replaced!", "Replace", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        [RelayCommand]
         private async void ReplaceWithCubeOption(IAppMesh mesh)
         {
             Vector3 center = _sceneManager.GetMeshCenter(mesh.GetG4Mesh());
             Vector3 meshDimensions = _sceneManager.GetMeshDimensions(mesh.GetG4Mesh());
        
             AppMesh cube = GeometryGenerator.CreateBox(
                         center,
                         meshDimensions.X,
                         meshDimensions.Y,
                         meshDimensions.Z
                     );
        
             var summaryToRemove = Meshes.FirstOrDefault(ms => ms.SourceMesh == mesh);
             if (summaryToRemove != null)
             {
                 Meshes.Remove(summaryToRemove);
             }
        
             _sceneManager.ReplaceMesh(mesh, cube);
        
             Meshes.Add(new MeshSummary(cube));
         }

         [RelayCommand]
         private async void ReplaceWithCubeClick()
         {
             var command = new SetReplaceStateCommand(_glControlHost, _mouseController, _sceneManager, new RayCaster(_glControlHost, _camera), _camera, _commandHistory, "cube");

             command.Execute();
             await ShowWpfMessageBoxAsync("Replaced!", "Replace", MessageBoxButton.OK, MessageBoxImage.Information);
         }

        [RelayCommand]
        private void ReplaceWithWedgeOption(IAppMesh mesh)
        {
            Vector3 center = _sceneManager.GetMeshCenter(mesh.GetG4Mesh());
            Vector3 meshDimensions = _sceneManager.GetMeshDimensions(mesh.GetG4Mesh());

            AppMesh wedge = GeometryGenerator.CreateWedge(
                center,
                meshDimensions.X,
                meshDimensions.Y,
                meshDimensions.Z
            );

            var summaryToRemove = Meshes.FirstOrDefault(ms => ms.SourceMesh == mesh);
            if (summaryToRemove != null)
            {
                Meshes.Remove(summaryToRemove);
            }

            _sceneManager.ReplaceMesh(mesh, wedge);

            Meshes.Add(new MeshSummary(wedge));
        }


        [RelayCommand]
        private async Task SimplifyQEC(IAppMesh mesh)
        {
            await RunPythonSimplificationSingle(mesh, "quadric_edge_collapse");
        }

        [RelayCommand]
        private async Task SimplifyFQD(IAppMesh mesh)
        {
            await RunPythonSimplificationSingle(mesh, "fast_quadric_decimation");
        }

        [RelayCommand]
        private async Task SimplifyVC(IAppMesh mesh)
        {
            await RunPythonSimplificationSingle(mesh, "vertex_clustering");
        }

        [RelayCommand]
        private async Task SimplifyAllQEC()
        {
            await RunPythonSceneSimplification("quadric_edge_collapse");
        }

        [RelayCommand]
        private async Task SimplifyAllFQD()
        {
            await RunPythonSceneSimplification("fast_quadric_decimation");
        }

        [RelayCommand]
        private async Task SimplifyAllVC()
        {
            await RunPythonSceneSimplification("vertex_clustering");
        }

        private async Task RunPythonSceneSimplification(string method)
        {
            if (Meshes.ToList().Count == 0)
            {
                await ShowWpfMessageBoxAsync("No meshes to simplify.", "Warning", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            var loadingWindow = new LoadingWindow
            {
                StatusHint = $"Simplifying all meshes… This may take a few moments.",
                Owner = System.Windows.Application.Current.MainWindow,
                IsProgressIndeterminate = true
            };
            loadingWindow.Show();

            if (method == "quadric_edge_collapse")
                loadingWindow.UpdateStatus($"Quadric Edge Collapse Simplification");
            else if (method == "fast_quadric_decimation")
                loadingWindow.UpdateStatus($"Fast Quadric Decimation");
            else if (method == "vertex_clustering")
                loadingWindow.UpdateStatus($"Vertex Clustering Simplification");

            try
            {
                // 1. Export all current meshes to a temp OBJ
                string? exportFile = _modelExporter.ExportToObj(Meshes.Select(m => m.SourceMesh).ToList(), $"scene_to_simplify.obj");
                if (exportFile == null)
                {
                    await ShowWpfMessageBoxAsync("Failed to export current scene.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                // 2. Prepare paths and arguments
                string simplifiedOutput = Path.Combine(Path.GetTempPath(), $"simplified_scene_{method}.obj");
                string exePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Scripts", "simplify.exe");
                float ratio = Math.Clamp(SimplificationRatio, 10, 100) / 100f;

                var startInfo = new ProcessStartInfo
                {
                    FileName = exePath,
                    Arguments = $"\"{exportFile}\" \"{simplifiedOutput}\" \"{method}\" \"{ratio}\"",
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                };

                using var process = new Process { StartInfo = startInfo };
                process.Start();
                string stdout = await process.StandardOutput.ReadToEndAsync();
                string stderr = await process.StandardError.ReadToEndAsync();
                await process.WaitForExitAsync();

                if (process.ExitCode != 0)
                {
                    await ShowWpfMessageBoxAsync($"simplify.exe error:\n{stderr}", "Simplification Failed", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                // 3. Import simplified mesh
                loadingWindow.UpdateStatus("Importing simplified mesh...");
                var simplifiedMeshes = _modelImporter.ImportModel(simplifiedOutput);
                if (simplifiedMeshes.Count == 0)
                {
                    await ShowWpfMessageBoxAsync("No mesh found in simplified result.", "Warning", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                // 4. Clear current scene and replace with new simplified mesh
                _sceneManager.ClearScene();
                Meshes.Clear();
                foreach (var simplified in simplifiedMeshes)
                {
                    _sceneManager.AddMesh(simplified);
                    Meshes.Add(new MeshSummary(simplified));
                }
            }
            catch (Exception ex)
            {
                await ShowWpfMessageBoxAsync($"Exception: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                loadingWindow.Close();
            }
        }

        private async Task RunPythonSimplificationSingle(IAppMesh mesh, string method)
        {
            // 1. Export just this single mesh to a temp file
            string tempName = $"temp_singlemesh_{Guid.NewGuid()}.obj";
            var tempFile = _modelExporter.ExportToObj(new List<IAppMesh> { mesh }, tempName);

            if (tempFile == null)
            {
                await ShowWpfMessageBoxAsync("Failed to export single mesh.", "Error",
                                             MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            // 2. Prepare the output from the simplify.exe
            string baseOutput = Path.Combine(Path.GetTempPath(), $"simplified_{method}.obj");

            // 3. Show a loading window
            var loadingWindow = new LoadingWindow
            {
                StatusHint = $"Simplifying mesh… This may take a while.",
                Owner = System.Windows.Application.Current.MainWindow,
                IsProgressIndeterminate = true
            };
            loadingWindow.Show();

            if (method == "quadric_edge_collapse")
                loadingWindow.UpdateStatus($"Quadric Edge Collapse Simplification");
            else if (method == "fast_quadric_decimation")
                loadingWindow.UpdateStatus($"Fast Quadric Decimation");
            else if (method == "vertex_clustering")
                loadingWindow.UpdateStatus($"Vertex Clustering Simplification");

            try
            {
                var exePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "Scripts", "simplify.exe");

                float ratio = Math.Clamp(SimplificationRatio, 10, 100) / 100f;

                var startInfo = new ProcessStartInfo
                {
                    FileName = exePath,
                    Arguments = $"\"{tempFile}\" \"{baseOutput}\" \"{method}\" \"{ratio}\"",
                    RedirectStandardOutput = true,
                    RedirectStandardError = true,
                    UseShellExecute = false,
                    CreateNoWindow = true
                };

                using var process = new Process { StartInfo = startInfo };
                process.Start();

                string stdout = await process.StandardOutput.ReadToEndAsync();
                string stderr = await process.StandardError.ReadToEndAsync();
                await process.WaitForExitAsync();

                if (process.ExitCode != 0)
                {
                    await ShowWpfMessageBoxAsync($"simplify.exe error:\n{stderr}",
                                                 "Simplification Failed",
                                                 MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                // 5. Re-import the simplified file
                var simplifiedMeshes = _modelImporter.ImportModel(baseOutput);
                if (simplifiedMeshes.Count > 0)
                {
                    var simplified = simplifiedMeshes[0];
                    _sceneManager.ReplaceMesh(mesh, simplified);

                    // 6. Update UI
                    var oldSummary = Meshes.FirstOrDefault(ms => ms.SourceMesh == mesh);
                    if (oldSummary != null)
                    {
                        Meshes.Remove(oldSummary);
                        Meshes.Add(new MeshSummary(simplified));
                    }
                }
            }
            catch (Exception ex)
            {
                await ShowWpfMessageBoxAsync($"Exception: {ex.Message}",
                                             "Error",
                                             MessageBoxButton.OK,
                                             MessageBoxImage.Error);
            }
            finally
            {
                loadingWindow.Close();
            }
        }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Shows a WPF MessageBox asynchronously using the UI Dispatcher.
        /// </summary>
        private static async Task<MessageBoxResult> ShowWpfMessageBoxAsync(string message, string title, MessageBoxButton button, MessageBoxImage image)
        {
            return await System.Windows.Application.Current.Dispatcher.InvokeAsync(() =>
            {
                // Activate main window so the MessageBox appears on top.
                System.Windows.Application.Current.MainWindow.Activate();
                return System.Windows.MessageBox.Show(
                    message,
                    title,
                    button,
                    image,
                    MessageBoxResult.OK,
                    System.Windows.MessageBoxOptions.DefaultDesktopOnly);
            });
        }

        private string? PromptForSaveLocation()
        {
            var dialog = new Microsoft.Win32.SaveFileDialog
            {
                Title = "Save Mesh As .obj",
                Filter = "Wavefront OBJ (*.obj)|*.obj",
                FileName = "export.obj"
            };

            // If user clicks 'Save'
            bool? result = dialog.ShowDialog();
            if (result == true)
            {
                return dialog.FileName;
            }
            return null;
        }

        // This method is auto-discovered by the MVVM source generator because its name matches
        // the property: On{PropertyName}Changed. It runs every time SelectedMesh actually changes.
        partial void OnSelectedMeshChanged(IAppMesh value)
        {
            // 1) If there was a previously highlighted mesh, restore it to the normal color.
            if (_lastSelectedMesh != null)
                _lastSelectedMesh.SetColor(_normalColor);

            // 2) If we have a new selection, apply the highlight color.
            if (value != null)
                value.SetColor(_highlightColor);

            // 3) Remember the current selection so we can un-highlight it next time.
            _lastSelectedMesh = value;

            // 4) Ask the GL view to repaint so the color change shows immediately.
            _glControlHost.Render();
        }

        /// <summary>
        /// Loads the mesh colors from settings into <c>normalColor</c> and <c>highlightColor</c>.
        /// Falls back to sensible defaults when a setting is missing or unrecognized.
        /// Call once from the constructor.
        /// </summary>
        private void LoadColors()
        {
            var rs = new RenderingSettings();

            _normalColor = ReadColorOrDefault(
                sectionKey: rs.GetKey(),
                settingName: RenderingSettings.MeshColor,
                fallback: Colors.Red,
                labelForLogs: "Mesh color"
            );

            _highlightColor = ReadColorOrDefault(
                sectionKey: rs.GetKey(),
                settingName: RenderingSettings.MeshHighlightColor,
                fallback: Colors.Blue,
                labelForLogs: "Mesh highlight color"
            );
        }
        /// <summary>
        /// Reads a color string from settings, tries to parse it via <see cref="TryParseColor"/>,
        /// and returns a fallback when parsing fails. Logs a warning when a non-empty value is unrecognized.
        /// </summary>
        /// <param name="sectionKey">Settings section key (e.g., from <see cref="RenderingSettings.GetKey"/>).</param>
        /// <param name="settingName">Concrete setting name (e.g., <see cref="RenderingSettings.MeshColor"/>).</param>
        /// <param name="fallback">Color used when value is missing or invalid.</param>
        /// <param name="labelForLogs">Human-readable label used in warnings.</param>
        /// <returns><see cref="Vector3"/> - The parsed color or the provided fallback.</returns>
        private Vector3 ReadColorOrDefault(string sectionKey, string settingName, Vector3 fallback, string labelForLogs)
        {
            // Fetch raw string (may be null/empty, localized, or user-entered)
            string? raw = _settingsManager.GetSetting<string>(sectionKey, settingName);

            // Parsed successfully
            if (TryParseColor(raw, out var parsedColor))
                return parsedColor;

            if (!string.IsNullOrWhiteSpace(raw))
                Debug.WriteLine($"Warning: {labelForLogs} '{raw}' not recognized. Using fallback.");

            return fallback;
        }
        /// <summary>
        /// Attempts to parse a color name into an RGB <see cref="Vector3"/> using the app's color map.
        /// Normalizes input (trim/lower/remove spaces) so values like "Light Blue" and "lightblue" match.
        /// </summary>
        /// <param name="raw">Raw color string from settings (may be null/empty).</param>
        /// <param name="color">Parsed color when the method returns <see langword="true"/>.</param>
        /// <returns><see langword="true"/> if parsing succeeded; otherwise <see langword="false"/>.</returns>
        /// <remarks>
        /// Future extension points:
        /// - Add hex support (e.g., #RRGGBB) or "r,g,b" numeric parsing.
        /// </remarks>
        private static bool TryParseColor(string? raw, out Vector3 color)
        {
            color = default;

            if (string.IsNullOrWhiteSpace(raw))
                return false;

            // Normalize: "Light Blue" -> "lightblue"
            string key = raw.Trim().ToLowerInvariant().Replace(" ", "");

            // use your existing map
            if (Colors.colorMap.TryGetValue(key, out color))
                return true;

            // (Optional) add hex support later, e.g. #RRGGBB -> Vector3
            // if (TryParseHex(key, out color)) return true;

            return false;
        }


        #endregion

        [RelayCommand]
        private void Exit()
        {
            System.Windows.Application.Current.Shutdown();
        }

        public void ApplyMeshThreshold()
        {
            _sceneManager.RemoveSmallMeshes(_latestImportedModel, SmallMeshThreshold);
            Meshes.Clear();

            var importedMeshes = _sceneManager.GetMeshes();

            foreach (var mesh in importedMeshes)
            {
                Meshes.Add(new MeshSummary(mesh));
            }

        }
    }
}
